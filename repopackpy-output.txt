================================================================
RepopackPy Output File
================================================================

This file was generated by RepopackPy on: 2024-11-09T19:06:58.585565

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and RepopackPy's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

For more information about RepopackPy, visit: https://github.com/abinthomasonline/repopack-py

================================================================
Repository Structure
================================================================
compose.yml
db\Dockerfile
db\__init__.py
db\conn.py
db\init.sql
db\repository.py
db\schema.py
game_logic.py
main.py
quiz_api.py
requirements.txt

================================================================
Repository Files
================================================================

================
File: compose.yml
================
services:
  db:
    build: 
      context: ./db
      dockerfile: Dockerfile
    restart: always
    user: postgres
    volumes:
      - db-data:/var/lib/postgresql/data
      - ./db/:/docker-entrypoint-initdb.d/
    environment:
      - POSTGRES_DB=fccpd
      - POSTGRES_PASSWORD=admin
    expose:
      - 5432
    ports:
      - "5435:5432"
    healthcheck:
      test: ["CMD", "pg_isready"]
      interval: 10s
      timeout: 5s
      retries: 5
volumes:
  db-data:

================
File: game_logic.py
================
from typing import Dict
from quiz_api import QuizAPI

class QuizGame:
    def __init__(self, api_key: str):
        self.quiz_api = QuizAPI(api_key)
        self.current_score = 0
        self.current_question = 0
        self.questions = []
        self.total_questions = 0

    def start_new_game(self, category: str = None, difficulty: str = None, 
                      num_questions: int = 10) -> None:
        print("Starting new game")
        """Start a new game by fetching questions"""
        self.questions = self.quiz_api.get_questions(
            category=category,
            difficulty=difficulty,
            limit=num_questions
        )
        print("Questions fetched")
        self.total_questions = len(self.questions)
        self.current_question = 0
        self.current_score = 0

    def get_current_question(self) -> Dict:
        """Get the current question details"""
        if self.current_question >= self.total_questions:
            return None
        return self.questions[self.current_question]

    def check_answer(self, user_answers: Dict[str, bool]) -> bool:
        """Check if the user's answer is correct"""
        current_q = self.questions[self.current_question]
        correct_answers = current_q['correct_answers']
        
        is_correct = True
        for answer_key, is_selected in user_answers.items():
            correct_key = answer_key.replace('answer_', 'correct_') + '_correct'
            if str(is_selected).lower() != str(correct_answers.get(correct_key, 'false')).lower():
                is_correct = False
                break

        if is_correct:
            self.current_score += 1
        self.current_question += 1
        return is_correct

    def is_game_over(self) -> bool:
        """Check if the game is over"""
        return self.current_question >= self.total_questions

    def get_game_summary(self) -> Dict:
        """Get the game summary"""
        return {
            'total_questions': self.total_questions,
            'correct_answers': self.current_score,
            'score_percentage': (self.current_score / self.total_questions) * 100 if self.total_questions > 0 else 0
        }

================
File: main.py
================
from datetime import datetime
from typing import Optional
from db.conn import DatabaseConnection
from db.schema import User, Question, Game
from db.repository import UserRepository, QuestionRepository, GameRepository
from game_logic import QuizGame
import logging

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

class QuizApplication:
    def __init__(self, api_key: str):
        self.db = DatabaseConnection()
        self.user_repo = UserRepository(self.db)
        self.game_repo = GameRepository(self.db)
        self.question_repo = QuestionRepository(self.db)
        self.game_logic = QuizGame(api_key)
        
    def register_user(self, username: str) -> Optional[User]:
        try:
            user = self.user_repo.create_user(username)
            logger.info(f"Created new user: {username}")
            return user
        except Exception as e:
            logger.error(f"Failed to create user: {str(e)}")
            return None
        
    def start_game(self, user_id: int, num_rounds: int) -> Optional[Game]:
        logger.info(f"Starting new game for user {user_id}")
        try:
            logger.debug(f"Fetching user {user_id}")
            # Create new game
            game = self.game_repo.create_game(user_id, num_rounds)
            logger.debug(f"Created game {game}")
            if not game:
                return None
                
            # Fetch questions from API
            logger.debug(f"Fetching questions from API")
            self.game_logic.start_new_game(num_questions=num_rounds)
            
            logger.debug(self.game_logic.questions)
            # Store questions in database
            logger.debug(f"Storing questions in database")
            question_ids = []
            for q in self.game_logic.questions:
                # Create question object
                logger.debug(f"Creating question object")
                question = Question(
                    id=0,  # Will be set by database
                    question=q['question'],
                    description=q.get('description', ''),
                    explanation=q.get('explanation', ''),
                    category=q.get('category', 'general'),
                    difficulty=q.get('difficulty', 'medium'),
                    answers=[q[f'answer_{i}'] for i in range(1, 5) if q.get(f'answer_{i}')],
                    correct_answers=[q[f'correct_answer_{i}_correct'] == 'true' 
                                   for i in range(1, 5) if q.get(f'answer_{i}')]
                )
                
                # Save question
                logger.debug(f"Saving question to database")
                saved_question = self.question_repo.create_question(question)
                question_ids.append(saved_question.id)
            
            # Link questions to game
            self.game_repo.add_game_questions(game.id, question_ids)
            
            logger.info(f"Started new game {game.id} for user {user_id}")
            return game
            
        except Exception as e:
            logger.error(f"Failed to start game: {str(e)}")
            return None
        
    def answer_question(self, game_id: int, question_id: int, 
                       answer_index: int) -> bool:
        try:
            # Get game and validate
            game = self.game_repo.get_game(game_id)
            if not game:
                logger.error(f"Game {game_id} not found")
                return False
                
            # Record answer
            conn = self.db.get_connection()
            try:
                with conn.cursor() as cur:
                    cur.execute("""
                        UPDATE game_questions 
                        SET selected_answer_index = %s,
                            answered_at = %s
                        WHERE game_id = %s AND question_id = %s
                        RETURNING id
                    """, (answer_index, datetime.now(), game_id, question_id))
                    conn.commit()
                    return True
            finally:
                self.db.return_connection(conn)
                
        except Exception as e:
            logger.error(f"Failed to record answer: {str(e)}")
            return False
        
    def close(self):
        try:
            self.db.close_all_connections()
            logger.info("Closed all database connections")
        except Exception as e:
            logger.error(f"Error closing connections: {str(e)}")
            
    def display_question(self, question: Question) -> None:
        print("\n" + "="*50)
        print(f"Question: {question.question}")
        if question.description:
            print(f"Description: {question.description}")
        print("\nAnswers:")
        for i, answer in enumerate(question.answers):
            print(f"{i+1}. {answer}")
            
    def play_game(self, game_id: int) -> None:
        try:
            game = self.game_repo.get_game(game_id)
            if not game:
                logger.error("Game not found")
                return

            questions = self.game_repo.get_game_questions(game_id)
            total_correct = 0

            for i, game_question in enumerate(questions, 1):
                question = self.question_repo.get_question_by_id(game_question.question_id)
                if not question:
                    continue

                self.display_question(question)
                
                while True:
                    try:
                        answer = int(input("\nEnter your answer (1-4): "))
                        if 1 <= answer <= len(question.answers):
                            break
                        print("Please enter a valid answer number")
                    except ValueError:
                        print("Please enter a number")

                # Convert to 0-based index
                answer_index = answer - 1
                is_correct = question.correct_answers[answer_index]
                
                # Update game question
                self.answer_question(game_id, question.id, answer_index)
                
                if is_correct:
                    total_correct += 1
                    print("\n✅ Correct!")
                else:
                    print("\n❌ Wrong!")
                
                if question.explanation:
                    print(f"Explanation: {question.explanation}")
                
                print(f"\nCurrent score: {total_correct}/{i}")

            # Update final score
            self.update_game_score(game_id, total_correct)
            print(f"\nGame Over! Final score: {total_correct}/{len(questions)}")

        except Exception as e:
            logger.error(f"Error during game play: {str(e)}")
            
    def update_game_score(self, game_id: int, score: int) -> bool:
        conn = self.db.get_connection()
        try:
            with conn.cursor() as cur:
                cur.execute("""
                    UPDATE games 
                    SET score = %s
                    WHERE id = %s
                """, (score, game_id))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"Failed to update score: {str(e)}")
            return False
        finally:
            self.db.return_connection(conn)
def main():
    app = QuizApplication("Nu4Q4o5IFPwgTUWcEmgWUpwyK06B3yGg3TbmkkTM")
    try:
        # Example usage
        username = input("Enter your username: ")
        user = app.register_user(username)
        if user:
            print(f"\nWelcome {username}!")
            while True:
                try:
                    rounds = int(input("How many questions would you like? (1-10): "))
                    if 1 <= rounds <= 10:
                        break
                    print("Please enter a number between 1 and 10")
                except ValueError:
                    print("Please enter a valid number")
            game = app.start_game(user.id, rounds)
            if game:
                app.play_game(game.id)
                play_again = input("\nWould you like to play again? (y/n): ")
                if play_again.lower() != 'y':
                    print("Thanks for playing!")
    finally:
        app.close()
        
if __name__ == '__main__':
    main()

================
File: quiz_api.py
================
import requests
from typing import List, Dict, Optional
import json

class QuizAPIError(Exception):
    def __init__(self, message: str, original_error: Exception = None):
        self.message = message
        self.original_error = original_error
        super().__init__(self.message)

class QuizAPI:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://quizapi.io/api/v1"
        self.headers = {
            "X-Api-Key": self.api_key
        }

    def get_questions(self, category: Optional[str] = None, difficulty: Optional[str] = None, 
                     limit: int = 10, tags: Optional[List[str]] = None) -> List[Dict]:
        """Fetch questions from QuizAPI"""
        endpoint = f"{self.base_url}/questions"
        params = {
            "limit": limit,
            "category": category,
            "difficulty": difficulty,
            "tags": tags
        }
        
        response = requests.get(endpoint, headers=self.headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            raise QuizAPIError(f"Failed to fetch questions: {response.status_code}")

================
File: db\conn.py
================
from psycopg2 import pool

class DatabaseConnection:
    def __init__(self):
        self.connection_pool = pool.SimpleConnectionPool(
            minconn=1,
            maxconn=10,
            database="fccpd",
            user="postgres",
            password="admin",
            host="localhost",
            port="5435"
        )
    
    def get_connection(self):
        return self.connection_pool.getconn()

    def return_connection(self, connection):
        self.connection_pool.putconn(connection)

    def close_all_connections(self):
        self.connection_pool.closeall()

================
File: db\Dockerfile
================
# Use official PostgreSQL image
FROM postgres:16

# Set environment variables
ENV POSTGRES_USER=postgres
ENV POSTGRES_PASSWORD=admin
ENV POSTGRES_DB=fccpd

# Expose PostgreSQL default port
EXPOSE 5432

# Copy initialization scripts
COPY init.sql /docker-entrypoint-initdb.d/

# Create volume for persistent data
VOLUME ["/var/lib/postgresql/data"]

# The default CMD from the postgres image will be used
# which runs postgres server

================
File: db\init.sql
================
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL
);

CREATE TABLE IF NOT EXISTS questions (
    id SERIAL PRIMARY KEY,
    question VARCHAR(255) NOT NULL,
    description VARCHAR(255),
    explanation VARCHAR(255),
    category VARCHAR(255) NOT NULL,
    difficulty VARCHAR(255) NOT NULL,
    answers jsonb NOT NULL,
    correct_answers jsonb NOT NULL
);

-- Create games table
CREATE TABLE IF NOT EXISTS games (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id),
    rounds INTEGER NOT NULL,
    score INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS game_questions (
    id SERIAL PRIMARY KEY,
    game_id INTEGER NOT NULL REFERENCES games(id),
    question_id INTEGER NOT NULL REFERENCES questions(id),
    selected_answer_key VARCHAR(50),
    is_correct BOOLEAN,
    answered_at TIMESTAMP,
    UNIQUE(game_id, question_id)
);

================
File: db\repository.py
================
from .conn import DatabaseConnection
from .schema import Question, Game, User, GameQuestion
from typing import List, Optional
import json

class UserRepository:
    def __init__(self, db_connection: DatabaseConnection):
        self.db = db_connection
    
    def create_user(self, username: str) -> Optional[User]:
        conn = self.db.get_connection()
        try:
            with conn.cursor() as cur:
                cur.execute("""
                    INSERT INTO users (username)
                    VALUES (%s)
                    RETURNING id
                """, (username,))
                user_id = cur.fetchone()[0]
                conn.commit()
                return User(id=user_id, username=username)
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            self.db.return_connection(conn)
    
    def get_user_by_id(self, user_id: int) -> Optional[User]:
        conn = self.db.get_connection()
        try:
            with conn.cursor() as cur:
                cur.execute("SELECT id, username FROM users WHERE id = %s", (user_id,))
                result = cur.fetchone()
                return User(id=result[0], username=result[1]) if result else None
        finally:
            self.db.return_connection(conn)

class QuestionRepository:
    def __init__(self, db_connection: DatabaseConnection):
        self.db = db_connection

    def create_question(self, question: Question) -> Optional[Question]:
        conn = self.db.get_connection()
        try:
            print("Creating question")
            with conn.cursor() as cur:
                answers_json = json.dumps(question.answers)
                correct_answers_json = json.dumps(question.correct_answers)
                cur.execute("""
                    INSERT INTO questions (
                        question, description, explanation, 
                        category, difficulty, answers, correct_answers
                    )
                    VALUES (%s, %s, %s, %s, %s, %s, %s)
                    RETURNING id
                """, (
                    question.question,
                    question.description,
                    question.explanation,
                    question.category,
                    question.difficulty,
                    answers_json,
                    correct_answers_json
                ))
                print("Question created")
                question_id = cur.fetchone()[0]
                conn.commit()
                
                # Update the question id and return
                question.id = question_id
                return question
                
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            self.db.return_connection(conn)

    def get_question_by_id(self, question_id: int) -> Optional[Question]:
        conn = self.db.get_connection()
        try:
            with conn.cursor() as cur:
                cur.execute("""
                    SELECT id, question, description, explanation, category, difficulty, answers, correct_answers
                    FROM questions
                    WHERE id = %s
                """, (question_id,))
                result = cur.fetchone()
                if result:
                    return Question(*result)
                return None
        finally:
            self.db.return_connection(conn)
            
    def check_answer(self, question_id: int, selected_answer_key: str) -> bool:
        conn = self.db.get_connection()
        try:
            with conn.cursor() as cur:
                cur.execute("""
                    SELECT correct_answers 
                    FROM questions 
                    WHERE id = %s
                """, (question_id,))
                result = cur.fetchone()
                if not result:
                    return False
                    
                correct_answers = json.loads(result[0])
                correct_key = f"correct_{selected_answer_key}_correct"
                return correct_answers.get(correct_key, False)
        finally:
            self.db.return_connection(conn)
            
class GameRepository:
    def __init__(self, db_connection: DatabaseConnection):
        self.db = db_connection
    
    def create_game(self, user_id: int, rounds: int) -> Optional[Game]:
        conn = self.db.get_connection()
        try:
            with conn.cursor() as cur:
                cur.execute("""
                    INSERT INTO games (user_id, rounds, score)
                    VALUES (%s, %s, 0)
                    RETURNING id, created_at
                """, (user_id, rounds))
                game_id, created_at = cur.fetchone()
                conn.commit()
                return Game(id=game_id, user_id=user_id, rounds=rounds, 
                          score=0, created_at=created_at)
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            self.db.return_connection(conn)
    
    def add_game_questions(self, game_id: int, question_ids: List[int]) -> bool:
        conn = self.db.get_connection()
        try:
            with conn.cursor() as cur:
                for question_id in question_ids:
                    cur.execute("""
                        INSERT INTO game_questions (game_id, question_id)
                        VALUES (%s, %s)
                    """, (game_id, question_id))
                conn.commit()
                return True
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            self.db.return_connection(conn)
    
    def get_game(self, game_id: int) -> Optional[Game]:
        conn = self.db.get_connection()
        try:
            with conn.cursor() as cur:
                cur.execute("""
                    SELECT id, user_id, rounds, score, created_at 
                    FROM games WHERE id = %s
                """, (game_id,))
                result = cur.fetchone()
                if result:
                    return Game(
                        id=result[0],
                        user_id=result[1],
                        rounds=result[2],
                        score=result[3],
                        created_at=result[4]
                    )
                return None
        finally:
            self.db.return_connection(conn)
    
    def get_game_questions(self, game_id: int) -> List[GameQuestion]:
        conn = self.db.get_connection()
        try:
            with conn.cursor() as cur:
                cur.execute("""
                    SELECT id, game_id, question_id, selected_answer_index, 
                           is_correct, answered_at
                    FROM game_questions 
                    WHERE game_id = %s
                """, (game_id,))
                return [
                    GameQuestion(
                        id=row[0],
                        game_id=row[1],
                        question_id=row[2],
                        selected_answer_index=row[3],
                        is_correct=row[4],
                        answered_at=row[5]
                    )
                    for row in cur.fetchall()
                ]
        finally:
            self.db.return_connection(conn)

================
File: db\schema.py
================
from dataclasses import dataclass
from typing import Optional, List, Dict
from datetime import datetime


@dataclass
class User:
    id: int
    username: str
    
@dataclass
class Question:
    id: int
    question: str
    description: str
    explanation: str
    category: str
    difficulty: str
    answers: Dict[str, str]
    correct_answers: Dict[str,bool]
    
@dataclass
class Game:
    id: int
    user_id: int
    rounds: int
    score: int
    created_at: datetime
    
@dataclass
class GameQuestion:
    id: int
    game_id: int
    question_id: int
    selected_answer_index: Optional[int]
    is_correct: Optional[bool]
    answered_at: Optional[datetime]
